/*
 * Copyright (c) 2016 Saugo360 and others.  All rights reserved.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License v1.0 which accompanies this distribution,
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 */
package org.opendaylight.tsdr.restconf.collector;

import java.util.ArrayList;
import java.util.Dictionary;
import java.util.Hashtable;
import java.util.List;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;

/**
 * This class is responsible for testing the TSDRRestconfCollectorConfig class.
 *
 * @author <a href="mailto:a.alhamali93@gmail.com">AbdulRahman AlHamali</a>
 *
 *         Created: Dec 16th, 2016
 *
 */
public class TSDRRestconfCollectorConfigTest {

    /**
     * the restconf collector config instance that we want to run our tests on.
     */
    private TSDRRestconfCollectorConfig configObject;

    /**
     * an array list with that saves the messages generated by the logger to inspect them later on.
     */
    private final List<String> logMessages = new ArrayList<>();

    /**
     * called before each test. It creates a mock logger that would add the logged message to logMessages list
     * everytime the logger.error function is called.
     * Also, the logMessages array is cleared, and the configObject is initialized
     */
    @Before
    public void setup() {
        Logger logger = Mockito.mock(Logger.class);
        logMessages.clear();
        Mockito.doAnswer(invocationOnMock -> {
            Object[] args = invocationOnMock.getArguments();
            logMessages.add((String)args[0]);
            return null;
        }).when(logger).error(Mockito.anyString());

        configObject = new TSDRRestconfCollectorConfig(logger);
    }

    /**
     * Tests the case when correct values are supplied in the configuration.
     * the values should be cached, and no error logs should be generated
     */
    @Test
    public void testCorrectValues() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals("GET,PUT", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals("/operations/.*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals("127\\.0\\.0\\.1", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(".*loggable.*", configObject.getProperty("CONTENT_TO_LOG"));
        Assert.assertEquals(0, logMessages.size());
    }

    /**
     * Tests the case when invalid http methods are supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testUnrecognizedMethod() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GERT,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("HTTP method GERT is not recognized", logMessages.get(0));
        Assert.assertEquals("Value specified for METHODS_TO_LOG: GERT,PUT is "
            + "invalid. Will use default value of POST,PUT,DELETE", logMessages.get(1));
    }

    /**
     * Tests the case when repeated http methods are supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testRepeatedMethod() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT,GET");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("HTTP method GET is repeated multiple times", logMessages.get(0));
        Assert.assertEquals("Value specified for METHODS_TO_LOG: GET,PUT,GET is "
            + "invalid. Will use default value of POST,PUT,DELETE", logMessages.get(1));
    }

    /**
     * Tests the case when no http methods are supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testMethodsEmpty() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("HTTP_METHODS_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for METHODS_TO_LOG:  is "
            + "invalid. Will use default value of POST,PUT,DELETE", logMessages.get(1));
    }

    /**
     * Tests the case when METHODS_TO_LOG property is removed from the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testMethodsNonExistent() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("HTTP_METHODS_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for METHODS_TO_LOG: null is "
            + "invalid. Will use default value of POST,PUT,DELETE", logMessages.get(1));
    }

    /**
     * Tests the case when an invalid regular expression is supplied for the paths in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testInvalidPathRegex() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "(");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals(true, logMessages.get(0).startsWith("Pattern ( is not parsable"));
        Assert.assertEquals("Value specified for PATHS_TO_LOG: ( is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when an empty paths expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testEmptyPath() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("PATHS_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for PATHS_TO_LOG:  is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when no paths expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testNonExistentPath() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("PATHS_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for PATHS_TO_LOG: null is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when an invalid regular expression is supplied for the remote addresses in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testInvalidRemoteAddressesRegex() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "(");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals(true, logMessages.get(0).startsWith("Pattern ( is not parsable"));
        Assert.assertEquals("Value specified for REMOTE_ADDRESSES_TO_LOG: ( is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when an empty remote addresses expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testEmptyRemoteAddresses() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("REMOTE_ADDRESSES_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for REMOTE_ADDRESSES_TO_LOG:  is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when no remote addresses expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testNonExistentRemoteAddresses() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("CONTENT_TO_LOG", ".*loggable.*");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("REMOTE_ADDRESSES_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for REMOTE_ADDRESSES_TO_LOG: null "
            + "is invalid. Will use default value of .*", logMessages.get(1));
    }

    /**
     * Tests the case when an invalid regular expression is supplied for the content in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testInvalidContentRegex() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", "(");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("CONTENT_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals(true, logMessages.get(0).startsWith("Pattern ( is not parsable"));
        Assert.assertEquals("Value specified for CONTENT_TO_LOG: ( is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when an empty content expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testEmptyContent() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");
        properties.put("CONTENT_TO_LOG", "");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("CONTENT_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("CONTENT_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for CONTENT_TO_LOG:  is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when no content expression is supplied in the configuration.
     * the default value should be used instead, and 2 meaningful error logs should be generated
     */
    @Test
    public void testNonExistentContent() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        properties.put("METHODS_TO_LOG", "GET,PUT");
        properties.put("PATHS_TO_LOG", "/operations/.*");
        properties.put("REMOTE_ADDRESSES_TO_LOG", "127\\.0\\.0\\.1");

        configObject.updated(properties);

        Assert.assertEquals(".*", configObject.getProperty("CONTENT_TO_LOG"));
        Assert.assertEquals(2, logMessages.size());
        Assert.assertEquals("CONTENT_TO_LOG is either empty or non-existent", logMessages.get(0));
        Assert.assertEquals("Value specified for CONTENT_TO_LOG: null is invalid. Will use default value of .*",
            logMessages.get(1));
    }

    /**
     * Tests the case when no properties at all are supplied in the configuration.
     * the default value should be used instead, and 1 meaningful error log should be generated
     */
    @Test
    public void testEmptyProperties() throws Exception {
        Dictionary<String, String> properties = new Hashtable<>();

        configObject.updated(properties);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("CONTENT_TO_LOG"));
    }

    /**
     * Tests the case when no configuration is supplied.
     * the default value should be used instead, and 1 meaningful error log should be generated
     */
    @Test
    public void testNonExistentProperties() throws Exception {

        configObject.updated(null);

        Assert.assertEquals("POST,PUT,DELETE", configObject.getProperty("METHODS_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("PATHS_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("REMOTE_ADDRESSES_TO_LOG"));
        Assert.assertEquals(".*", configObject.getProperty("CONTENT_TO_LOG"));
        Assert.assertEquals(0, logMessages.size());
    }
}
